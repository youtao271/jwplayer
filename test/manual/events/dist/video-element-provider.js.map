{"version":3,"file":"video-element-provider.js","sources":["webpack:///webpack/bootstrap","webpack:///./src/providers/video-element-provider.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/providers/video-element-provider.ts\");\n","import type { ImplementedProvider, ProviderEvents, SeekRange } from '../../../../../src/js/providers/default';\nimport type Events from '../../../../../src/js/utils/backbone.events';\nimport type { InternalPlayerState } from '../../../../../src/js/events/events';\nimport type PlaylistItem from '../../../../../src/js/playlist/item';\nimport type { PlaylistItemSource } from '../../../../../src/js/playlist/source';\nimport type { QualityLevel } from '../../../../../src/js/providers/data-normalizer';\n\nconst jwplayer = window.jwplayer;\nconst PROVIDER_NAME = 'headless-video-element';\n\n// Provider events not implemented in the example:\n// \"bandwidthEstimate\" (We're letting the browser handle network activity here)\n// \"metadataCueParsed\" and \"meta\" events (emsg, id3, program-date-time...) (See html5.ts)\n\n// The ImplementedProvider interface matches internal providers\n// These changes reflect the interface required for any provider registered with jwplayer\ninterface CustomProvider extends Omit<ImplementedProvider,\n    'prototype'|'seeking'|'stallTime'|'instreamMode'|'renderNatively'|'supports'|'video'|\n    'getCurrentTime'|'getDuration'|'getSeekRange'|'getLiveLatency'|'setCurrentSubtitleTrack'|'setControls'|\n    'getBandwidthEstimate'|'isLive'> {\n    attachMedia(): void;\n    detachMedia(): void;\n}\n\ninterface VideoElementProvider {\n    // These methods are added in the constructor\n    // See src/js/utils/backbone.events.ts\n    on: CustomProvider['on'];\n    once: CustomProvider['once'];\n    off: CustomProvider['off'];\n    trigger: CustomProvider['trigger'];\n    // These 'DefaultProvider' methods are added to the prototype\n    // See src/js/providers/default.ts and src/js/providers/providers-register.ts\n    sendMediaType: (sources: Array<PlaylistItemSource>) => void;\n    setState: (state: InternalPlayerState) => void;\n}\n\ntype PlayerConfig = {\n    // Select an adaptation based on last bandwidthEstimate event from previous session\n    bandwidthEstimate: number | null,\n    // The user made a manual adaptation selection which had a bitrate of this value in the previous session\n    bitrateSelection: number | null\n}\n\nclass VideoElementProvider implements CustomProvider {\n\n    private static video?: HTMLVideoElement;\n\n    public name: string;\n    public state: InternalPlayerState;\n    public supportsPlaybackRate: boolean;\n    public container: HTMLDivElement | null;\n\n    private item: PlaylistItem;\n    private videoElement: HTMLVideoElement;\n    private config: { [key: string]: any };\n    private seeking: boolean;\n    private seekFromTime: number | null;\n    private seekToTime: number | null;\n    private stallTime: number | null;\n    private visualQuality: ProviderEvents['visualQuality'];\n    private readonly listenerDictionary: { [key: string]: any };\n    private audioTracksChangeHandler: (this: VideoElementProvider) => void;\n    private subtitleTracksChangeHandler: (this: VideoElementProvider) => void;\n    private currentQuality: number;\n    private currentAudioTrack: number;\n    private currentSubtitleTrack: number;\n    private subtitleTracksDispatched: boolean;\n\n    static supports(source: PlaylistItemSource): boolean {\n        if (source.type === 'custom-type') {\n            return true;\n        }\n        const video = VideoElementProvider.video = VideoElementProvider.video || document.createElement('video');\n        const mimeType = source.mimeType || {\n            aac: 'audio/mp4',\n            mp4: 'video/mp4',\n            f4v: 'video/mp4',\n            m4v: 'video/mp4',\n            mov: 'video/mp4',\n            mp3: 'audio/mpeg',\n            mpeg: 'audio/mpeg',\n            ogv: 'video/ogg',\n            ogg: 'video/ogg',\n            oga: 'video/ogg',\n            vorbis: 'video/ogg',\n            webm: 'video/webm',\n            f4a: 'video/aac',\n            m3u8: 'application/vnd.apple.mpegurl',\n            m3u: 'application/vnd.apple.mpegurl',\n            hls: 'application/vnd.apple.mpegurl'\n        }[source.type];\n        return !!(video && video.canPlayType && video.canPlayType(mimeType));\n    }\n\n    static getName(): { name: string } {\n        return {\n            name: PROVIDER_NAME\n        };\n    }\n\n    static isLive(duration) {\n        return duration === Infinity;\n    }\n\n    static isDvr(seekableDuration, minDvrWindow) {\n        return seekableDuration !== Infinity && Math.abs(seekableDuration) >= minDvrWindow;\n    }\n\n    constructor(playerId: string, config: PlayerConfig, mediaElement: HTMLVideoElement) {\n        // Add event listener methods used by the player to this instance\n        // See src/js/utils/backbone.events.ts\n        const backboneEvents: Events = jwplayer(playerId).Events;\n        Object.assign(this, backboneEvents);\n\n        // This video element comes from a pool managed by the player for dealing with autoplay policy\n        // and ads playback, but you could also use or create your own.\n        this.videoElement = mediaElement;\n        this.audioTracksChangeHandler = this.audioTracksChange.bind(this);\n        this.subtitleTracksChangeHandler = this.subtitleTracksChange.bind(this);\n        this.currentQuality = -1;\n        this.currentAudioTrack = -1;\n        this.currentSubtitleTrack = -1;\n        this.subtitleTracksDispatched = false;\n        this.name = PROVIDER_NAME;\n        this.state = 'idle';\n        this.supportsPlaybackRate = true;\n        this.item = null;\n        this.container = null;\n        this.config = config;\n        this.seeking = false;\n        this.seekFromTime = null;\n        this.seekToTime = null;\n        this.stallTime = null;\n        this.visualQuality = {\n            reason: 'initial choice',\n            mode: 'auto',\n            bitrate: 0,\n            level: {\n                width: 0,\n                height: 0,\n                index: 0,\n                label: ''\n            }\n        };\n\n        // Enable to use element controls rather than JW's\n        // window.jwplayer(playerId).setControls(false);\n        // this.videoElement.setAttribute('controls', '');\n\n        // Update state and trigger jwplayer events in response to changes on the video element\n        const videoEventCallbacks = {\n            click(this: VideoElementProvider, evt: Event) {\n                this.trigger('click', evt);\n            },\n            loadedmetadata(this: VideoElementProvider) {\n                this.trigger('meta', {\n                    metadataType: 'media',\n                    duration: this.getDuration(),\n                    height: this.videoElement.videoHeight,\n                    width: this.videoElement.videoWidth,\n                    seekRange: this.getSeekRange()\n                });\n            },\n            loadeddata(this: VideoElementProvider) {\n                if (this.videoElement.getStartDate) {\n                    // Get 'program-date-time' from this.videoElement.getStartDate() in Safari\n                }\n                this.dispatchAudioTracks();\n                this.dispatchSubtitleTracks();\n            },\n            durationchange(this: VideoElementProvider) {\n                this.listenerDictionary.progress.call(this);\n            },\n            canplay(this: VideoElementProvider) {\n                const mediaType = (this.videoElement.videoHeight === 0) ? 'audio' : 'video';\n                this.trigger('mediaType', { mediaType });\n                this.trigger('bufferFull');\n            },\n            play(this: VideoElementProvider) {\n                if (!this.videoElement.paused && this.state !== 'playing') {\n                    this.setState('loading');\n                }\n            },\n            playing(this: VideoElementProvider) {\n                this.trigger('providerFirstFrame');\n                this.setState('playing');\n            },\n            pause(this: VideoElementProvider) {\n                if (this.state === 'complete' ||\n                    this.videoElement.ended ||\n                    this.videoElement.error ||\n                    this.videoElement.currentTime === this.videoElement.duration) {\n                    return;\n                }\n                this.setState('paused');\n            },\n            timeupdate(this: VideoElementProvider) {\n                const duration = this.getDuration();\n                if (isNaN(duration)) {\n                    return;\n                }\n                const currentTime = this.videoElement.currentTime;\n                if (!this.seeking && !this.videoElement.paused &&\n                    (this.state === 'stalled' || this.state === 'loading') &&\n                    this.stallTime !== currentTime) {\n                    this.stallTime = -1;\n                    this.listenerDictionary.playing.call(this);\n                }\n                const position = this.getCurrentTime();\n                const seekRange = this.getSeekRange();\n                const timeEvent: ProviderEvents['time'] = {\n                    position,\n                    duration,\n                    currentTime,\n                    seekRange,\n                    metadata: {\n                        currentTime\n                    }\n                };\n                const latency = this.getLiveLatency();\n                if (latency !== null) {\n                    timeEvent.latency = latency;\n                }\n\n                if (this.seekToTime === null) {\n                    this.seekFromTime = currentTime;\n                }\n                // only emit time events when playing or seeking\n                if (this.state === 'playing' || this.seeking) {\n                    this.trigger('time', timeEvent);\n                }\n            },\n            ratechange(this: VideoElementProvider) {\n                this.trigger('ratechange', { playbackRate: this.videoElement.playbackRate });\n            },\n            seeking(this: VideoElementProvider) {\n                const offset = this.seekToTime !== null ? this.timeToPosition(this.seekToTime) : this.getCurrentTime();\n                const position = this.timeToPosition(this.seekFromTime || 0);\n                this.seekFromTime = this.seekToTime;\n                this.seekToTime = null;\n                this.seeking = true;\n                this.trigger('seek', {\n                    position,\n                    offset\n                });\n            },\n            seeked(this: VideoElementProvider) {\n                if (!this.seeking) {\n                    return;\n                }\n                this.seeking = false;\n                this.trigger('seeked');\n            },\n            progress(this: VideoElementProvider) {\n                const duration = this.getDuration();\n                const buffered = this.videoElement.buffered;\n                if (duration <= 0 || duration === Infinity || !buffered || buffered.length === 0) {\n                    return;\n                }\n                const bufferPercent = 100 * Math.min(Math.max(buffered.end(buffered.length - 1) / duration, 0), 1);\n                this.trigger('bufferChange', {\n                    bufferPercent,\n                    position: this.getCurrentTime(),\n                    duration,\n                    currentTime: this.videoElement.currentTime,\n                    seekRange: this.getSeekRange()\n                });\n            },\n            waiting(this: VideoElementProvider) {\n                if (this.seeking) {\n                    this.setState('loading');\n                } else if (this.state === 'playing') {\n                    if (this.atEdgeOfLiveStream()) {\n                        this.setPlaybackRate(1);\n                    }\n                    this.stallTime = this.videoElement.currentTime;\n                    this.setState('stalled');\n                }\n            },\n            resize(this: VideoElementProvider) {\n                const { videoElement } = this;\n                const { videoWidth, videoHeight } = videoElement;\n                // Trigger 'visualQuality' when videoWidth or videoHeight changes\n                const level = this.visualQuality.level;\n                if (level.width !== videoWidth || level.height !== videoHeight) {\n                    const visualQuality: ProviderEvents['visualQuality'] = {\n                        level: {\n                            width: videoWidth,\n                            height: videoHeight,\n                            index: 0,\n                            label: ''\n                        },\n                        bitrate: 0,\n                        mode: 'auto', // 'manual' for manual quality selection\n                        reason: 'auto', // 'initial choice' for first resize after loading new item\n                    };\n                    this.visualQuality = visualQuality;\n                    this.trigger('visualQuality', visualQuality);\n                }\n            },\n            volumechange(this: VideoElementProvider) {\n                this.trigger('volume', {\n                    volume: Math.round(this.videoElement.volume * 100)\n                });\n\n                this.trigger('mute', {\n                    mute: this.videoElement.muted\n                });\n            },\n            ended(this: VideoElementProvider) {\n                if (this.state !== 'idle' && this.state !== 'complete') {\n                    this.trigger('complete');\n                }\n            },\n            error(this: VideoElementProvider, sourceError) {\n                this.videoElement.removeAttribute('src');\n                this.videoElement.load();\n                const error = {\n                    code: 290000, // Unknown Provider Error\n                    sourceError\n                };\n                this.trigger('mediaError', error);\n            }\n        };\n\n        this.listenerDictionary = {};\n        Object.keys(videoEventCallbacks).forEach(eventName => {\n            this.listenerDictionary[eventName] = videoEventCallbacks[eventName].bind(this);\n        });\n    }\n\n    getName(): { name: string } {\n        return VideoElementProvider.getName();\n    }\n\n    attachMedia(): void {\n        this.seeking = false;\n        this.seekFromTime = null;\n        this.seekToTime = null;\n        // Reset video element settings\n        this.videoElement.loop = false;\n        // Add video element event listeners\n        const listenerDictionary = this.listenerDictionary;\n        Object.keys(listenerDictionary).forEach(eventName => {\n            this.videoElement.removeEventListener(eventName, listenerDictionary[eventName]);\n            this.videoElement.addEventListener(eventName, listenerDictionary[eventName]);\n        });\n        const audioTracks = this.videoElement.audioTracks;\n        if (audioTracks) {\n            audioTracks.removeEventListener('change', this.audioTracksChangeHandler);\n            audioTracks.addEventListener('change', this.audioTracksChangeHandler);\n        }\n        const textTracks = this.videoElement.textTracks;\n        if (textTracks) {\n            textTracks.removeEventListener('change', this.subtitleTracksChangeHandler);\n            textTracks.addEventListener('change', this.subtitleTracksChangeHandler);\n        }\n    }\n\n    detachMedia(): void {\n        if (!this.videoElement) {\n            return;\n        }\n        const listenerDictionary = this.listenerDictionary;\n        Object.keys(listenerDictionary).forEach(eventName => {\n            this.videoElement.removeEventListener(eventName, listenerDictionary[eventName]);\n        });\n        const audioTracks = this.videoElement.audioTracks;\n        if (audioTracks) {\n            audioTracks.removeEventListener('change', this.audioTracksChangeHandler);\n        }\n        const textTracks = this.videoElement.textTracks;\n        if (textTracks) {\n            textTracks.removeEventListener('change', this.subtitleTracksChangeHandler);\n        }\n    }\n\n    init(item: PlaylistItem): void {\n        this.item = item;\n        this.state = 'idle';\n        this.currentQuality = -1;\n        this.currentAudioTrack = -1;\n        this.currentSubtitleTrack = -1;\n        this.subtitleTracksDispatched = false;\n        this.attachMedia();\n    }\n\n    preload(item: PlaylistItem): void {\n        this.item = item;\n        if (item.image) {\n            this.videoElement.setAttribute('poster', item.image);\n        }\n        // Up to you to pick from available adaptations once they are known. This is just a quick hack to pick\n        // from a list of mp4 source, or the one HLS source in Safari.\n        this.currentQuality = Math.floor(item.sources.length / 3);\n        this.setVideoSource(item.sources[this.currentQuality]);\n        this.videoElement.load();\n    }\n\n    load(item: PlaylistItem): void {\n        this.item = item;\n        const previousSource = this.videoElement.src;\n        this.currentQuality = this.currentQuality < 0 ? Math.floor(item.sources.length / 3) : this.currentQuality;\n        this.setVideoSource(item.sources[this.currentQuality]);\n        const sourceChanged = previousSource !== this.videoElement.src;\n        if (sourceChanged) {\n            // Do not call load if src was not set. load() will cancel any active play promise.\n            if (previousSource) {\n                this.videoElement.load();\n            }\n        } else if (item.starttime === 0 && this.videoElement.currentTime > 0) {\n            // Load event is from the same video as before\n            // restart video without dispatching seek event\n            this.seek(item.starttime);\n        }\n\n        // Check if we have already seeked the mediaElement before _completeLoad has been called\n        if (item.starttime > 0 && this.videoElement.currentTime !== item.starttime) {\n            this.seek(item.starttime);\n        }\n\n        // This should be triggered when adaptation sets are known\n        // In this case we can't provide manual quality selection so just report a single level\n        const levels = this.getQualityLevels();\n\n        this.trigger('levels', {\n            levels,\n            currentQuality: this.currentQuality\n        });\n    }\n\n    volume(vol: number): void {\n        this.videoElement.volume = Math.min(Math.max(0, vol / 100), 1);\n    }\n\n    mute(state: string): void {\n        this.videoElement.muted = !!state;\n    }\n\n    resize(width: number, height: number, stretching: string): void {\n        const { videoWidth, videoHeight } = this.videoElement;\n        if (!width || !height || !videoWidth || !videoHeight) {\n            return;\n        }\n        this.videoElement.style.objectFit = '';\n        if (stretching === 'uniform') {\n            // Snap video to edges when the difference in aspect ratio is less than 9% and perceivable\n            const playerAspectRatio = width / height;\n            const videoAspectRatio = videoWidth / videoHeight;\n            const edgeMatch = Math.abs(playerAspectRatio - videoAspectRatio);\n            if (edgeMatch < 0.09 && edgeMatch > 0.0025) {\n                this.videoElement.style.objectFit = 'fill';\n            }\n        }\n    }\n\n    getContainer(): HTMLDivElement | null {\n        return this.container;\n    }\n\n    setContainer(element: HTMLDivElement): void {\n        this.container = element;\n        if (element && this.videoElement.parentNode !== element) {\n            element.appendChild(this.videoElement);\n        }\n    }\n\n    removeFromContainer(): void {\n        const { container, videoElement } = this;\n        this.container = null;\n        if (container && container === videoElement.parentNode) {\n            container.removeChild(videoElement);\n        }\n    }\n\n    public remove(): void {\n        const container = this.container;\n        const video = this.videoElement;\n        this.stop();\n        this.destroy();\n        if (container) {\n            container.removeChild(video);\n        }\n    }\n\n    public stop(): void {\n        this.seeking = false;\n        if (this.videoElement) {\n            this.videoElement.removeAttribute('preload');\n            this.videoElement.removeAttribute('src');\n            this.videoElement.load();\n        }\n        this.setState('idle');\n    }\n\n    public destroy(): void {\n        this.off();\n        this.detachMedia();\n        this.item = null;\n        this.seeking = false;\n        this.container = null;\n        // @ts-ignore\n        this.config = null;\n        // @ts-ignore\n        this.videoElement = null;\n        // @ts-ignore\n        this.audioTracksChangeHandler = null;\n        // @ts-ignore\n        this.subtitleTracksChangeHandler = null;\n    }\n\n    public supportsFullscreen(): boolean {\n        return true;\n    }\n\n    public setVisibility(state): void {\n        state = !!state;\n        if (this.container) {\n            this.container.style.opacity = state ? '1' : '0';\n        }\n    }\n\n    public play(): Promise<void> {\n        return this.videoElement.play();\n    }\n\n    public pause(): void {\n        this.videoElement.pause();\n    }\n\n    public seek(toPosition: number) {\n        const seekRange = this.getSeekRange();\n        if (toPosition < 0) {\n            this.seekToTime = toPosition + seekRange.end;\n        } else {\n            this.seekToTime = toPosition;\n        }\n        this.seeking = true;\n        this.seekFromTime = this.videoElement.currentTime;\n        this.videoElement.currentTime = this.seekToTime;\n    }\n\n    public getPlaybackRate(): number {\n        return this.videoElement.playbackRate;\n    }\n\n    public setPlaybackRate(playbackRate: number) {\n        this.videoElement.playbackRate = this.videoElement.defaultPlaybackRate = playbackRate;\n    }\n\n    public getCurrentQuality(): number {\n        return this.currentQuality;\n    }\n\n    public setCurrentQuality(currentQuality: number): void {\n        // Implement based on availability of manual bitrate selection\n        if (currentQuality > -1 && this.currentQuality !== currentQuality &&\n            this.item.sources && currentQuality < this.item.sources.length) {\n            this.currentQuality = currentQuality;\n            const levels = this.getQualityLevels();\n            this.trigger('levelsChanged', {\n                currentQuality,\n                levels\n            });\n            const playing = !this.videoElement.paused;\n            const currentTime = this.videoElement.currentTime;\n            this.setVideoSource(this.item.sources[currentQuality]);\n            this.videoElement.currentTime = currentTime;\n            if (playing) {\n                this.videoElement.play();\n            }\n        }\n    }\n\n    public getQualityLevels(): QualityLevel[] {\n        return this.item.sources.map(source => ({\n            bitrate: source.bitrate || 0,\n            label: source.label || `${source.height}p`,\n            width: source.width,\n            height: source.height\n        }));\n    }\n\n    public setCurrentAudioTrack(currentTrack: number): void {\n        if (currentTrack > -1 && this.videoElement) {\n            const audioTracks = this.videoElement.audioTracks;\n            if (currentTrack === this.currentAudioTrack || !audioTracks || currentTrack >= audioTracks.length) {\n                return;\n            }\n            this.currentAudioTrack = currentTrack;\n            audioTracks[currentTrack].enabled = true;\n            const tracksArray = [].slice.call(audioTracks);\n            const tracks = tracksArray.map((track: AudioTrack) => ({\n                name: track.label || track.language,\n                language: track.language\n            }));\n            this.trigger('audioTrackChanged', { currentTrack, tracks });\n        }\n    }\n\n    public setSubtitlesTrack(oneIndexedTrackIndex: number) {\n        this.dispatchSubtitleTracks();\n        const currentTrack = oneIndexedTrackIndex - 1;\n        if (currentTrack > -1 && this.videoElement && this.videoElement.textTracks) {\n            const textTracks = this.videoElement.textTracks;\n            const tracks = [].slice.call(textTracks).filter((track: TextTrack) => track.kind === 'subtitles');\n            if (currentTrack === this.currentSubtitleTrack || currentTrack >= tracks.length) {\n                return;\n            }\n            this.currentSubtitleTrack = currentTrack;\n            tracks.forEach(track => track.mode = 'disabled');\n            tracks[currentTrack].mode = 'showing';\n            // Here's an annoying bug where currentTrack is required to be one-indexed even though it should be 0\n            // This event is required for captions functionality, unless you want external changes made\n            // to the video textTracks to be reflected in JW Player.\n            this.trigger('subtitlesTrackChanged', { currentTrack: oneIndexedTrackIndex, tracks });\n        }\n    }\n\n    public getCurrentAudioTrack(): number {\n        return 0;\n    }\n    public getAudioTracks(): { name: string, language: string }[] {\n        return [];\n    }\n\n    public getFullscreen(): boolean {\n        // Only return true if the video element itself is fullscreen (not the app/page/player)\n        return false;\n    }\n\n    public setFullscreen(isFullscreen: boolean): void {\n        // Request for the video element to go fullscreen, because the player is unable (iOS)\n    }\n\n    private getCurrentTime(): number {\n        const currentTime = this.videoElement.currentTime;\n        const seekRange = this.getSeekRange();\n        if (VideoElementProvider.isLive(this.videoElement.duration)) {\n            if (VideoElementProvider.isDvr(seekRange.end - seekRange.start, Math.max(this.config.minDvrWindow, 30))) {\n                return currentTime - seekRange.end;\n            }\n        }\n        return currentTime;\n    }\n\n    private getDuration(): number {\n        let duration = this.videoElement.duration;\n        // Don't sent time event on Android before real duration is known\n        if (isNaN(duration)) {\n            return 0;\n        }\n        const end = this.getSeekableEnd();\n        if (VideoElementProvider.isLive(this.videoElement.duration) && end) {\n            const seekableDuration = end - this.getSeekableStart();\n            if (VideoElementProvider.isDvr(seekableDuration, Math.max(this.config.minDvrWindow, 30))) {\n                // Player interprets negative duration as DVR\n                duration = -seekableDuration;\n            }\n        }\n        return duration;\n    }\n\n    private getSeekRange(): SeekRange {\n        const seekRange: SeekRange = {\n            start: 0,\n            end: 0\n        };\n        const seekable = this.videoElement.seekable;\n        if (seekable.length) {\n            seekRange.end = this.getSeekableEnd();\n            seekRange.start = this.getSeekableStart();\n        } else if (isFinite(this.videoElement.duration)) {\n            seekRange.end = this.videoElement.duration;\n        }\n        return seekRange;\n    }\n\n    private getSeekableStart(): number {\n        let start = Infinity;\n        ['buffered', 'seekable'].forEach(range => {\n            const timeRange = this.videoElement[range];\n            let index = timeRange ? timeRange.length : 0;\n            while (index--) {\n                const rangeStart = Math.min(start, timeRange.start(index));\n                if (isFinite(rangeStart)) {\n                    start = rangeStart;\n                }\n            }\n        });\n        return start;\n    }\n\n    private getSeekableEnd(): number {\n        let end = 0;\n        ['buffered', 'seekable'].forEach(range => {\n            const timeRange = this.videoElement[range];\n            let index = timeRange ? timeRange.length : 0;\n            while (index--) {\n                const rangeEnd = Math.max(end, timeRange.end(index));\n                if (isFinite(rangeEnd)) {\n                    end = rangeEnd;\n                }\n            }\n        });\n        return end;\n    }\n\n    private timeToPosition(time: number): number {\n        if (VideoElementProvider.isLive(this.videoElement.duration)) {\n            const seekRange = this.getSeekRange();\n            if (VideoElementProvider.isDvr(seekRange.end - seekRange.start, Math.max(this.config.minDvrWindow, 30))) {\n                return Math.min(0, time - seekRange.end);\n            }\n        }\n        return time;\n    }\n\n    private atEdgeOfLiveStream(): boolean {\n        if (!VideoElementProvider.isLive(this.videoElement.duration)) {\n            return false;\n        }\n        // currentTime doesn't always get to the end of the buffered range\n        const timeFudge = 2;\n        const buffered = this.videoElement.buffered;\n        const endOfRange = (buffered && buffered.length) ? buffered.end(buffered.length - 1) : 0;\n        return (endOfRange - this.videoElement.currentTime) <= timeFudge;\n    }\n\n    private getLiveLatency(): number | null {\n        let latency: number | null = null;\n        const end = this.getSeekableEnd();\n        if (VideoElementProvider.isLive(this.videoElement.duration) && end) {\n            latency = end - this.videoElement.currentTime;\n        }\n        return latency;\n    }\n\n    private setVideoSource(source: PlaylistItemSource): void {\n        const preload = source.preload || 'metadata';\n        if (this.videoElement.getAttribute('preload') !== preload) {\n            this.videoElement.setAttribute('preload', preload);\n        }\n        const sourceElement = document.createElement('source');\n        sourceElement.src = source.file;\n        const sourceChanged = (this.videoElement.src !== sourceElement.src);\n        if (sourceChanged) {\n            this.videoElement.src = source.file;\n        }\n    }\n\n    private dispatchAudioTracks(): void {\n        const audioTracks = this.videoElement.audioTracks;\n        if (audioTracks && audioTracks.length) {\n            const tracksArray = [].slice.call(audioTracks);\n            let currentTrack = tracksArray.findIndex((track: AudioTrack) => track.enabled);\n            if (currentTrack === -1) {\n                currentTrack = 0;\n                audioTracks[0].enabled = true;\n            }\n            const tracks = tracksArray.map((track: AudioTrack) => ({\n                name: track.label || track.language,\n                language: track.language\n            }));\n            audioTracks.removeEventListener('change', this.audioTracksChangeHandler);\n            audioTracks.addEventListener('change', this.audioTracksChangeHandler);\n            this.trigger('audioTracks', { currentTrack, tracks });\n        }\n    }\n\n    private audioTracksChange(): void {\n        const tracksArray = [].slice.call(this.videoElement.audioTracks);\n        const currentTrack = tracksArray.findIndex((track: AudioTrack) => track.enabled);\n        this.setCurrentAudioTrack(currentTrack);\n    }\n\n    private dispatchSubtitleTracks(): void {\n        if (this.subtitleTracksDispatched) {\n            return;\n        }\n        const textTracks = this.videoElement.textTracks;\n        if (textTracks && textTracks.length) {\n            this.subtitleTracksDispatched = true;\n            const tracks = [].slice.call(textTracks).filter((track: TextTrack) => track.kind === 'subtitles');\n            textTracks.removeEventListener('change', this.subtitleTracksChangeHandler);\n            textTracks.addEventListener('change', this.subtitleTracksChangeHandler);\n            this.trigger('subtitlesTracks', { tracks });\n        }\n    }\n\n    private subtitleTracksChange(): void {\n        const textTracks = this.videoElement.textTracks;\n        const tracks = [].slice.call(textTracks).filter((track: TextTrack) => track.kind === 'subtitles');\n        const currentTrack = tracks.findIndex((track: TextTrack) => track.mode === 'showing');\n        this.setSubtitlesTrack(currentTrack + 1);\n    }\n}\n\njwplayer.api.registerProvider(VideoElementProvider);\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3EA;AACA;AAGA;AACA;AAEA;AACA;AACA;AA4BA;AAyBA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAaA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AALA;AASA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAAA;AACA;AACA;AAVA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAFA;AAIA;AACA;AA5KA;AA+KA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAFA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;AAEA;;;;A","sourceRoot":""}